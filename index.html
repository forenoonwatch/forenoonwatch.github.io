<!doctype html>

<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta charset="utf-8">
		<title>The Forenoon Watch</title>
		<link rel="shortcut icon" href="images/favicon.ico">
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		<div class="main">
			<h1>The Forenoon Watch</h1>

			<div class="layoutbox">
				<div class="box">
					<div class="box">
						<h3>About</h3>
						<p>I am a 22 year old C++ programmer with interests in graphics programming, game engine development, and game development. My hobbies include art, music, and maritime history. This page is devoted to my personal programming projects. The projects linked and discussed here are by no means an extensive sample of my work, and many have been lost over time as I changed computers.</p>
						<p>I have been programming since 2012, and working on games and game engines for nearly as long. From the start, many of my projects have been driven by my study of maritime history, ship physics, and oceanography. Some of these projects have even led to my publishing an undergraduate research paper on ocean rendering.</p>

						<p>Please keep in mind I am a bit new to the blog posting format, but I believe it is the best way for me to convey the value of my fragmented collection of projects.</p>
					</div>
					<div class="box">
						<h3>Contact</h3>
						<p>Although this website is intended to be somewhat of a portfolio, due to my conviction to personal privacy, I will not put my personal information on this website, nor on my GitHub. If this website was not linked in conjunction with a resume but you would like to discuss employment, please send an inquiry to my email.</p>
						<a href="https://github.com/forenoonwatch">GitHub</a> <br>
						<a href="mailto: Forenoon Watch <admin@forenoon.watch>">Email: admin@forenoon.watch</a>
					</div>
				</div>
			</div>
			<div class="layoutbox">
				<div class="box">
					<div class="box">
						<h3>Featured Projects</h3>
						A quick reference to some of my most interesting projects.
						<ul class="projectlist">
							<li>
								<img class="projecticon" src="images/ocean_rendering_thumb.png">
								<div class="projectdesc">
									<h4><a href="#rendering_an_ocean">Rendering an Ocean</a></h4>
									<p>
									Simulating ocean water based on Jerry Tessendorf's 2004 paper.
									</p>
								</div>
							</li>
							<li>
								<img class="projecticon" src="images/greenfoot3d_thumb.png">
								<div class="projectdesc">
									<h4><a href="#greenfoot3d">Drawing Outside the Lines I - Greenfoot 3D</a></h4>
									<p>
									3D software renderer written within an educational 2D game engine.
									</p>
								</div>
							</li>
							<li>
								<img class="projecticon" src="images/console_images_thumb.png">
								<div class="projectdesc">
									<h4><a href="#console_images">Drawing Outside the Lines II - Console Images</a></h4>
									<p>
									Rendering images and GIFs in windows cmd.exe.
									</p>
								</div>
							</li>
							<li>
								<img class="projecticon" src="images/block_systems_thumb.png">
								<div class="projectdesc">
									<h4><a href="https://github.com/forenoonwatch/block-systems">Block Systems</a></h4>
									<p>
									One of my later hobby engines, features my various experiments with voxel-based physics, buoyancy, and networking.
									</p>
								</div>
							</li>
							<li>
								<img class="projecticon" src="images/nx_engine_thumb.png">
								<div class="projectdesc">
									<h4><a href="https://github.com/forenoonwatch/nx-engine">NX Engine</a></h4>
									<p>
									Engine repository that goes in conjunction with block-systems, contains my work with handmade physics engines, rendering with PBR, ECS, and various other features.
									</p>
								</div>
							</li>
						</ul>
					</div>
					<div class="box">
						<h3>Future Projects</h3>
						Some of my upcoming projects, mostly a planner for myself more than anything.
						<h4>Console Rendering</h4>
						<ul>
							<li>OpenGL &amp; Vulkan</li>
						</ul>
						<h4>Game Engine Programming</h4>
						<ul>
							<li>Coroutine-based job scheduler</li>
							<li>Virtual file system</li>
							<li>Engine core - allocators, containers, etc</li>
							<li>Entity Component System</li>
							<li>Vulkan rendering engine</li>
							<li>IBL Skybox Generation Tool</li>
							<li>Physics Engine - Attempt 2</li>
						</ul>
						<h4>Music/Audio</h4>
						<ul>
							<li>Casio WK-6600 live-looper/augmentation tool</li>
						</ul>
					</div>
				</div>
			</div>
			<div class="layoutbox">
				<div class="box">
					<div class="box">
						<h3>Interesting Articles</h3>
						Interesting references/articles for various topics. This isn't a comprehensive list of the sources I've found/used over the years, but some of the most interesting ones that are tougher to find.
						<ul>
							<li>Engine Development
								<ul>
									<li><a href="http://www.swedishcoding.com/2015/03/08/gdc-2015-presentation-parallelizing-the-naughty-dog-engine/">GDC 2015 - Parallelizing the Naughty Dog Engine</a></li>
									<li><a href="https://gafferongames.com/categories/game-networking/">Game Networking - Glenn Fielder</a></li>
									<li><a href="https://www.gamedevs.org/uploads/tribes-networking-model.pdf">Tribes Networking Model</a></li>
								</ul>
							</li>
							<li>Rendering
								<ul>
									<li><a href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/">Writing an Efficient Vulkan Renderer</a></li>
									<li><a href="http://chunkstories.xyz/blog/a-note-on-descriptor-indexing/">A Note on Descriptor Indexing</a></li>
									<li><a href="http://kylehalladay.com/blog/tutorial/vulkan/2018/01/28/Textue-Arrays-Vulkan.html">Using Arrays of Textures in Vulkan Shaders</a></li>
									<li><a href="https://www.advances.realtimerendering.com/s2015/aaltonenhaar_siggraph2015_combined_final_footer_220dpi.pdf">GPU-Driven Rendering Pipelines</a></li>
									<li><a href="https://www.elopezr.com/a-macro-view-of-nanite/">A Macro View of Nanite</a></li>
								</ul>
							</li>
							<li>Game Physics
								<ul>
									<li><a href="https://kevinyu.net/2018/01/17/understanding-constraint-solver-in-physics-engine/">Understanding Constraint Solver in Physics Engine</a></li>
								</ul>
							</li>
							<li>Maritime
								<ul>
									<li><a href="https://www.amazon.com/Seamanship-Age-Sail-Man-War/dp/0870219553">Seamanship in the Age of Sail - John Harland</a></li>
								</ul>
							</li>
						</ul>
					</div>
					<div class="box">
						<h3>Inspirations</h3>
						Blogs, videos, articles, and books written by other programmers that impact my work in a large way.
						<h4>People:</h4>
						<ul>
							<li>Eskil Steenberg
								<ul>
									<li><a href="https://www.youtube.com/watch?v=443UNeGrFoM">Presentation - "How I Program C"</a></li>
									<li><a href="https://www.youtube.com/watch?v=MJmqaWq7PJY">Presentation - "Where do I get all my ideas?"</a></li>
								</ul>
							</li>
							<li>Joel Yliluoma (Bisqwit)
								<ul>
									<li><a href="https://bisqwit.iki.fi/">Website</a></li>
									<li><a href="https://www.youtube.com/c/Bisqwit">YouTube Channel</a></li>
								</ul>
							</li>
							<li>Arseny Kapoulkine
								<ul>
									<li><a href="https://zeux.io/">Website</a></li>
								</ul>
							</li>
							<li>Sean T. Barrett
								<ul>
									<li><a href="https://github.com/nothings">GitHub</a></li>
									<li><a href="https://www.youtube.com/watch?v=eAhWIO1Ra6M">Presentation - "Advice for Writing Small Programs in C"</a></li>
								</ul>
							</li>
							<li>Erin Catto
								<ul>
									<li><a href="https://box2d.org/">Box 2D</a></li>
								</ul>
							</li>
							<li>Randy Gaul
								<ul>
									<li><a href="http://www.randygaul.net/">Blog</a></li>
									<li><a href="https://github.com/randygaul">GitHub</a></li>
								</ul>
							</li>
							<li>bennyqbd/thebennybox
								<ul>
									<li><a href="https://www.youtube.com/user/thebennybox">YouTube</a></li>
								</ul>
							</li>
						</ul>
						<h4>Topics:</h4>
						<ul>
							<li>Web Design
								<ul>
									<li><a href="http://gamepipeline.org">gamepipeline.org</a></li>
									<li><a href="https://bisqwit.iki.fi/">bisqwit.iki.fi</a></li>
									<li><a href="http://cplusplus.com/">cplusplus.com</a></li>
									<li><a href="https://gifypet.neocities.org/">GIFYPET</a></li>
									<li><a href="http://grape65535.jp/games/ggsim/">HIGH-MACS simulator</a></li>
									<li><a href="http://www.lemis.com/grog/index.php">Greg 'Groggy' Lehey</a></li>
								</ul>
							</li>
						</ul>
					</div>
				</div>
			</div>
			<div class="layoutbox">
				<div class="box">
					<div class="box" id="console_images">
						<h3>Drawing Outside the Lines II - Console Images</h3>
						<img class="blogstrip" src="images/console_images_blog_strip.png">
						<h5>October 21, 2021</h5>
						<h4>Background</h4>
						<p>Ever since I started programming C++ back in my freshman year of high school, I wanted to be able to manipulate graphics in the console. Most C++ programming courses begin and end with user I/O handled through <code>std::cin</code> and <code>std::cout</code>, with no mention of graphics or even alternate text colors. During my time in that course, "Programming in C++", I would spend extra time when I got home from school digging through the Windows API documentation and finding functions like <code>SetConsoleTextAttribute</code>, <code>SetConsoleCursorPosition</code>, and <code>GetAsyncKeyState</code> which allowed me to use cmd as a rudimentary window for making actual interactive games. In fact, for my final project I implemented Battleship with 16 color text-block rendering and full mouse and keyboard support. Pictured is the title screen of the game as it appears today, and sadly it is mostly nonfunctional on Windows 10.</p>
						<a href="images/console_images_blog_1.png" title="Click for full size image"><img src="images/console_images_blog_1.png" width="200"></a>
						<p>Even back then, through my searching for ways to render on the console, I had seen discussion on using <code>SetPixel</code> on the console window, but at the time I did not understand what I was doing well enough to make it work. Recently however, I decided on a whim to try again, and managed to manipulate the console's pixels, and with further experimentation I was even able to draw bitmaps.</p>
						<h4>Implementation</h4>
						<p>The fundamental mechanics behind rendering an image to the console are acquiring a GDI Device Context handle (HDC) to the console window, and creating Device Independent Bitmaps (DIB) to render to the screen. Getting the console HDC is a simple matter of acquiring the console window handle (HWND) via <code>FindWindowA("ConsoleWindowClass", NULL)</code>, and getting its context via the GDI function <code>GetDC</code>.</p>
						<p>With the console's HDC you must then create a compatible device context to be used for each bitmap via <code>CreateCompatibleDC</code>. This HDC is the handle to the context of the bitmap you will create, and is used for both creating the bitmap and actually rendering it to the console window. With a correctly configured bitmap header, you can then create a device indepentent bitmap for your image with <code>CreateDIBSection</code>. This function leaves you with a <code>void*</code> pointer to the memory for the bitmap, which can be filled with image data acquired by any means. (more detail provided in<a href="https://github.com/forenoonwatch/console-images/blob/master/src/graphic.cpp">graphic.cpp</a>).</p>
						<p>For this project, I opted to use<a href="https://github.com/nothings/stb/blob/master/stb_image.h">STB Image,</a>as it is a lightweight and convenient solution for loading still images and animated GIFs. To get the data in a format compatible with the DIB, the images must be flipped vertically and have their RGB data reordered to BGR. The GIF animation is handled by copying a given frame's image data into the bitmap memory based on the frame delay timings read from the GIF.</p>
						<p>To actually draw the image to the screen, the function <code>StretchBlt</code> is used, which can resize any sized image to fit in a convenient size for the console, which I have set to a height constraint of 10 console lines.</p>
						<a href="images/console_images_blog_2.gif" title="Click to see full size image"><img src="images/console_images_blog_2.gif" width="400"></a>
						<h4>Repository Link</h4>
						<a href="https://github.com/forenoonwatch/console-images">GitHub - Console Images</a>
					</div>
				</div>
			</div>
			<div class="layoutbox">
				<div class="box">
					<div class="box" id="greenfoot3d">
						<h3>Drawing Outside the Lines I - Greenfoot 3D</h3>
						<img class="blogstrip" src="images/greenfoot3d_blog_strip.png">
						<h5>October 20, 2021</h5>
						<h4>Introduction</h4>
						<p>Around sophomore year of high school, in Java class, I wrote a 3D software rendering extension to the 2D educational "game engine"<a href="https://www.greenfoot.org/door">Greenfoot.</a>It is perhaps my first instance of attempting to "draw outside the lines" and render things where they don't belong. The original intent was to use it for the final project, which was to make a game with a group of people, but I discarded that idea pretty quickly since making a 3D game from scratch in a few weeks is a much taller order than making a barebones rendering engine. The engine features scanline-rasterized triangles, depth buffering, texture sampling, as well as various attempts at handy game engine features such as AABB colliders, billboard renderers, camera controllers, and sound emitters.</p>
						<a href="images/greenfoot3d_blog_1.png" title="Normal Greenfoot - Click to see full size image"><img src="images/greenfoot3d_blog_1.png" width="200"></a>
						<a href="images/greenfoot3d_blog_2.png" title="Greenfoot 3D - Click to see full size image"><img src="images/greenfoot3d_blog_2.png" width="200"></a>
						<h4>Implementation</h4>
						<p>The fundamental mechanic which allows the engine to even be possible is the API function <code>GreenfootImage.getAwtImage()</code> which exposes access to the underlying BufferedImage. With access to the BufferedImage, I can access its buffer as an integer array and perform very fast writes of pixel data. The core of the rendering engine is implemented by setting the background of the game to be a special GreenfootImage subclass called RenderContext, through which I perform most of the triangle rasterization log and pixel manipulation logic, which ultimately gets stored in the image buffer.</p>
						<p>Unfortunately, the biggest drawback is that the underlying Actor system within Greenfoot cannot be used in conjunction with the 3D engine, partially due to the fact that the entirety of the game is being rendered on the world background. This resulted in the implementation of the GameObject and GameComponent classes, in order to make my own actor system in place of Greenfoot's.</p>
						<a href="images/greenfoot3d_blog_3.gif" title="Greenfoot 3D - Click to see full size image"><img src="images/greenfoot3d_blog_3.gif" width="400"></a>
						<h4>Repository Link</h4>
						<a href="https://github.com/forenoonwatch/Greenfoot3D">GitHub - Greenfoot3D</a>
					</div>
				</div>
			</div>
			<div class="layoutbox">
				<div class="box">
					<div class="box" id="rendering_an_ocean">
						<h3>Rendering an Ocean</h3>
						<img class="blogstrip" src="images/ocean_rendering_blog_strip.png">
						<h5>October 19, 2021</h5>
						<h4>Introduction</h4>
						<p>Ocean rendering is a complex and challenging problem for real time rendering, as oceans are exceedingly large, constantly changing, and comprised of a large volume of translucent material that interacts with light in complex ways. When rendering an ocean, there are three major components for creating a realistic real time ocean environment: the waveform, the world model, and the lighting.</p>
						<h4>Waveform</h4>
						<p>One of the most fundamental aspects of a realistic ocean is its shape, which is determined by a simulation of its many compounding waves. There are several methods to accomplish this, with some of the most popular being either Gerstner waves, or Jerry Tessendorf's method of applying an inverse Fourier transform to a grid of wave data in the frequency domain, which to my knowledge does not have as slick of a name, so I will henceforth refer to it as Tessendorf waves.</p>
						<p>For my simulation, I chose Tessendorf waves over Gerstner waves, as Gerstner waves require a much slower, iterative calculation of waveforms comprised of multiplying and summing sine waves for each point of interest. While this is quite intuitive and simple to implement, it is not as efficient for the large number of waves required to make an ocean look realistic. Tessendorf's method provides an obvious optimization to summing sine waves, which is to utilize the Fast Fourier Transform (FFT) and apply it to a set of wave data in the frequency domain. Listed in his<a href="https://people.cs.clemson.edu/~jtessen/reports/papers_files/coursenotes2004.pdf">paper</a>is a realistic-looking ocean wave frequency model called the Phillips spectrum, which provides a conveniently tileable set of waves in an nxn grid.</p>
						<h4>World Model</h4>
						<p>Since the ocean is very large, and often in the context of a game, essentially infinite, various tricks have to be utilized to only render the parts of the ocean relevant to the observer. Ideally, this means rendering no more than what is in the viewport. While multiple methods exist for this, with varying trade-offs between efficiency and detail, I chose Claes Johanson's<a href="https://fileadmin.cs.lth.se/graphics/theses/projects/projgrid/projgrid-hq.pdf">projected grid</a>method. This method takes a grid of vertices and projects them with a smooth, continuous level-of-detail onto the intersection of the camera frustum and the ocean plane. This results in extremely efficient utilization of rendered geometry.</p>
						<a href="images/ocean_rendering_blog_1.png" title="Click to see full size image"><img src="images/ocean_rendering_blog_1.png" width="200"></a>
						<h4>Lighting</h4>
						<p>In recent years, a common method of real-time lighting for games has been Physically Based Rendering (PBR) combined with Image Based Lighting (IBL). Through the use of heuristic equations that attempt to mimic light interacting with surfaces of various roughness and metallicity, much of the work for rendering a plausible ocean is already included in the implementation of these equations, which include diffuse lighting, specular lighting, ambient lighting (through IBL), environmental reflection maps (also through IBL), and the Fresnel effect. Some effects are not present however, such as translucency, transparency, and subsurface scattering, which I have made attempts at implementing with various degrees of success.</p>
						<a href="images/ocean_rendering_blog_2.png" title="Click to see full size image"><img src="images/ocean_rendering_blog_2.png" width="200"></a>
						<h4>Catmull-Rom Interpolation</h4>
						<p>Since I chose to use a fairly low resolution texture for my Tessendorf ocean tile (256x256), mapping the waves onto the world model left it with some artifacts. To alleviate this I implemented Catmull-Rom interpolation of the ocean's displacement map to smooth out the sampling. This method allows me to get more detail out of the ocean data at the cost of more texture samples per vertex.</p>
						<a href="images/ocean_rendering_blog_3.png" title="Early in development - Click to see full size image"><img src="images/ocean_rendering_blog_3.png" width="200"></a>
						<a href="images/ocean_rendering_blog_4.png" title="Later in development - Click to see full size image"><img src="images/ocean_rendering_blog_4.png" width="200"></a>
						<h4>Repository Link</h4>
						<a href="https://github.com/forenoonwatch/ocean-rendering">GitHub - Ocean Rendering</a>
					</div>
				</div>
			</div>
			<br clear="all">
		</div>
	</body>
</html>
